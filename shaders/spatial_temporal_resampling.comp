#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters

#extension GL_NV_shader_sm_builtins : require     // Debug - gl_WarpIDNV, gl_SMIDNV
#extension GL_ARB_gpu_shader_int64 : enable       // Debug - heatmap value
#extension GL_EXT_shader_realtime_clock : enable  // Debug - heatmap timing

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable

#include "host_device.h"

layout(push_constant) uniform _RtxState
{
  RtxState rtxState;
};

#include "globals.glsl"

#include "layouts.glsl"
#include "random.glsl"
#include "common.glsl"
#include "random.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

Ray raySpawn(ivec2 coord, ivec2 sizeImage) {
    // Compute sampling position between [-1 .. 1]
    const vec2 pixelCenter = vec2(coord) + 0.5;
    const vec2 inUV = pixelCenter / vec2(sizeImage.xy);
    vec2 d = inUV * 2.0 - 1.0;
    // Compute ray origin and direction
    vec4 origin = sceneCamera.viewInverse * vec4(0, 0, 0, 1);
    vec4 target = sceneCamera.projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = sceneCamera.viewInverse * vec4(normalize(target.xyz), 0);
    return Ray(origin.xyz, normalize(direction.xyz));
}

float Luminance(vec3 color)
{
    return dot(color, vec3(0.299f, 0.587f, 0.114f));
}

// TODO: For now just return the luminance as the weight function(unnormalized target function)
float EvalTargetPdf(vec3 Li, vec3 vPos, vec3 sPos)
{
	// TODO: BSDFcos * Li
	return Luminance(Li);
}

// Merge two reservoirs(merge r2 into r1 r1 <- r2)
bool MergeReservoir(inout uint rseed, inout Reservoir r1, Reservoir r2, float r2TargetPdf, inout float weightS)
{
	// Compute the weight of the second reservoir
	float r2Weight = r2.M * max(0.f, r2.weightF) * r2TargetPdf;

	// Compute the weight sum
	weightS += r2Weight;

	// Update sample count M
	r1.M += r2.M;

	// Get a random number
	float randomNum = rand(rseed);

	// Return this flag to show if use the second reservoir's sample or not
	bool isUpdate = (randomNum * weightS <= r2Weight) || weightS == 0;

	// Update the reservoir r1
	if(isUpdate)
	{
		r1.sPos = r2.sPos;
		r1.sNorm = r2.sNorm;
		r1.radiance = r2.radiance;
		r1.age = r2.age;
		r1.rcEnv = r2.rcEnv;
		r1.rcEnvDirPacked = r2.rcEnvDirPacked;
	}

	return isUpdate;
}

void ComputeFinalWeight(inout Reservoir resv, float targetPdf, float weightSum)
{
	float weight = targetPdf * resv.M;
	resv.weightF = weight > 0 ? weightSum / weight : 0;
}

void StResample(ivec2 imageCoords)
{
	uint idx = rtxState.size.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x;

	// Create a random seed
	uint rSeed = tea(idx, rtxState.frame * rtxState.maxSamples);

	// Get reconnection data of this pixel
	ReconnectionData rcData = reconnectionDataBuffer[idx];

	// If the pixel has no reconnection data, return
	if(rcData.preRcVertexHitInfo == vec4(0))
	{
		// imageStore(resultImage, imageCoords, vec4(1.0f, 0.0f, 0.0f, 1.f));
		return;
	}
	// vec3 albedo = unpackUnorm4x8(rcData.preRcVertexHitInfo.w).rgb;
	// imageStore(resultImage, imageCoords, vec4(albedo, 1.f));
	
	// Get the initial sample of the pixel
	Reservoir initialResvSample = initialReserviors[idx];

	// Compute the world space position of the pixel
	const vec2 pixelCenter = vec2(imageCoords) + vec2(0.5f);
    const vec2 inUV = pixelCenter / vec2(rtxState.size.xy);
    vec2       d = inUV * 2.0 - 1.0;

	// Compute ray direction
    vec4 origin = sceneCamera.viewInverse * vec4(0, 0, 0, 1);
    vec4 target = sceneCamera.projInverse * vec4(d.x, d.y, 1, 1);
    vec4 direction = normalize(sceneCamera.viewInverse * vec4(normalize(target.xyz), 0));

	// Spawwn ray to get origin and direction
	Ray ray = raySpawn(imageCoords, ivec2(rtxState.size.xy));

	// Get the Depth from the GBuffer
	float depth = uintBitsToFloat(imageLoad(thisGbuffer, imageCoords).r);

	// Compute the world space position of the pixel
	vec4 worldPos = vec4(ray.origin + ray.direction * depth, 1.0f);
	imageStore(debugImage, imageCoords, worldPos);

	// Camera matrix in the previous fram
	mat4 prevViewProj = rtxState.prevProjMat * rtxState.prevViewMat;

	// Compute the previous screen space position of the pixel
	vec4 prevPosView = rtxState.prevViewMat * worldPos;
	vec4 prevPosClip = prevViewProj * worldPos;
	vec3 preScreen = prevPosClip.xyz / prevPosClip.w;
	vec2 preUV = preScreen.xy * vec2(0.5f, -0.5f) + 0.5f;
	ivec2 preID = ivec2(clamp(preUV * rtxState.size, vec2(0), vec2(rtxState.size - ivec2(1))));

	// Get the previous linear index
	uint preIdx = rtxState.size.x * preID.y + preID.x;

	// Temporal Check
	// Check if the prev sample is valid
	bool isPreValid = (rtxState.frame > 0) && all(greaterThan(preUV, vec2(0.0f))) && all(lessThan(preUV, vec2(1.0f)));

	// Get the previous sample
	Reservoir temporalPrevReservoir = prevReserviors[preIdx];

	// If the temporal sample is valid, check the geometry
	if(isPreValid)
	{
		// TODO: 0.1, 0.8 are the threshold values
		isPreValid = (length(temporalPrevReservoir.vPos - initialResvSample.vPos) < 0.1f && dot(initialResvSample.vNorm, temporalPrevReservoir.vNorm) > 0.9f);

		// Get the prev Camera Pos
		vec3 prevCamPos = vec3(inverse(rtxState.prevViewMat) * vec4(0,0,0,1));

		// Check the depth
		float viewDepth = length(rtxState.cameraPos - initialResvSample.vPos);
		float prevViewDepth = length(prevCamPos - initialResvSample.vPos);

		// a random number to discard temporal sample
		float randNum = rand(rSeed);

		// If the depth has difference and rand less than 0.15, discard the temporal sample
		if(viewDepth / prevViewDepth < 0.98f && randNum < 0.0f)
		{
			isPreValid = false;
		}
	}

	// Temporal Reuse
	temporalPrevReservoir.M = clamp(temporalPrevReservoir.M, 0, 30);
	if(!isPreValid || temporalPrevReservoir.age > 100)
	{
		// If the temporal sample is not valid or is too old, reset M
		temporalPrevReservoir.M = 0;
	}

	temporalPrevReservoir.M = 0;

	// Get the target pdf of the prev reservoir
	float tpPrev = EvalTargetPdf(temporalPrevReservoir.radiance, initialResvSample.vPos, temporalPrevReservoir.sPos);

	// Compute the weight sum(weightF = Weight_s / (M * targetpdf))
	float wSum = temporalPrevReservoir.M * tpPrev * max(0.f, temporalPrevReservoir.weightF);

	// Get the target pdf of the current reservoir
	float tpCurrent = EvalTargetPdf(initialResvSample.radiance, initialResvSample.vPos, initialResvSample.sPos);

	// merge initialResvSample and temporalPrevReservoir
	bool isUpdate = MergeReservoir(rSeed, temporalPrevReservoir, initialResvSample, tpCurrent, wSum);

	// Compute new target pdf
	float tpNew = EvalTargetPdf(temporalPrevReservoir.radiance, initialResvSample.vPos, temporalPrevReservoir.sPos);

	// Compute final weight
	ComputeFinalWeight(temporalPrevReservoir, tpNew, wSum);
	temporalPrevReservoir.M = clamp(temporalPrevReservoir.M, 0, 30);
	temporalPrevReservoir.age++;

	// Set current vPos and vNormal
	temporalPrevReservoir.vPos = initialResvSample.vPos;
    temporalPrevReservoir.vNorm = initialResvSample.vNorm;

	// Write the temporal reservoir to the current buffer
	currentReserviors[preIdx] = temporalPrevReservoir;

	// Debug
	vec4 colorValue = vec4(vec2(preID) / vec2(rtxState.size - ivec2(1)), 1.0f, 1.0f);
	// imageStore(resultImage, imageCoords, vec4(float(isPreValid)));

	// DebugFloatBuffer
	if(idx == 0)
	{
		debugFloatBuffer[6] = rtxState.cameraPos.x;
		debugFloatBuffer[7] = rtxState.cameraPos.y;
		debugFloatBuffer[8] = rtxState.cameraPos.z;

		debugFloatBuffer[3] = ray.direction.x;
		debugFloatBuffer[4] = ray.direction.y;
		debugFloatBuffer[5] = ray.direction.z;
	}
}

//
//--------------------------------------------------------------------------------------------------
//
//
void main()
{
	uint64_t start = clockRealtimeEXT();  // Debug - Heatmap

	ivec2 imageRes    = rtxState.size;
	ivec2 imageCoords = ivec2(gl_GlobalInvocationID.xy);  //SampleSizzled();

	// Check if the pixel is outside the image
	if(imageCoords.x >= imageRes.x || imageCoords.y >= imageRes.y)
	{
		return;
	}


	StResample(imageCoords);
	return;
}