#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters

#extension GL_NV_shader_sm_builtins : require     // Debug - gl_WarpIDNV, gl_SMIDNV
#extension GL_ARB_gpu_shader_int64 : enable       // Debug - heatmap value
#extension GL_EXT_shader_realtime_clock : enable  // Debug - heatmap timing

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable

#include "host_device.h"

layout(push_constant) uniform _RtxState
{
  RtxState rtxState;
};


#include "globals.glsl"

PtPayload        prd;
ShadowHitPayload shadow_payload;

#include "layouts.glsl"
#include "random.glsl"
#include "common.glsl"
#include "traceray_rq.glsl"

#include "pathtrace_initial.glsl"

#define FIREFLIES 1

//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
#ifndef SWIZZLED
layout(local_size_x = 8, local_size_y = 8) in;
#else
layout(local_size_x = 32, local_size_y = 2) in;
#extension GL_EXT_shader_8bit_storage : enable  // Using uint_8 ...
ivec2 SampleSizzled()
{
  // Sampling Swizzling
  // Convert 32x2 to 8x8, where the sampling will follow how invocation are done in a subgroup.
  // layout(local_size_x = 32, local_size_y = 2) in;
  ivec2 base   = ivec2(gl_WorkGroupID.xy) * 8;
  ivec2 subset = ivec2(int(gl_LocalInvocationID.x) & 1, int(gl_LocalInvocationID.x) / 2);
  subset += gl_LocalInvocationID.x >= 16 ? ivec2(2, -8) : ivec2(0, 0);
  subset += ivec2(gl_LocalInvocationID.y * 4, 0);
  return base + subset;
}
#endif

//
//--------------------------------------------------------------------------------------------------
//
//
void main()
{
  uint64_t start = clockRealtimeEXT();  // Debug - Heatmap

  ivec2 imageRes    = rtxState.size;
  ivec2 imageCoords = ivec2(gl_GlobalInvocationID.xy);  //SampleSizzled();

  // Check if the pixel is outside the image
  if(imageCoords.x >= imageRes.x || imageCoords.y >= imageRes.y)
  {
	return;
  }

  uint idx = rtxState.size.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x;

  // Initialize the seed for the random number only once once
  // uvec2 s    = pcg2d(imageCoords * int(clockARB()));
  // prd.seed = s.x + s.y;
  prd.seed = tea(rtxState.size.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, rtxState.frame * rtxState.maxSamples);
  //prd.seed = initRandom(uvec2(imageRes), gl_GlobalInvocationID.xy, rtxState.frame);

  // Sampling the pixel
  vec3 pixelColor = vec3(0);
  for(int smpl = 0; smpl < rtxState.maxSamples; ++smpl)
  {
    pixelColor += samplePixel_Initial(imageCoords, ivec2(imageRes), idx);

    // For debug
    // // Albedo
    // samplePixel_Initial(imageCoords, ivec2(imageRes), idx);
    // vec3 albedo = unpackUnorm4x8(reconnectionDataBuffer[idx].preRcVertexHitInfo.w).rgb;

    // // Normal
    // vec3 normal = decompress_unit_vec(reconnectionDataBuffer[idx].preRcVertexHitInfo.y);
    // // normal = decompress_unit_vec(imageLoad(thisGbuffer, imageCoords).y);
    // normal = (normal + vec3(1.0f)) / 2.0f;

    // // metallic, roughness
    // vec2 metallicRoughness = unpackUnorm4x8(reconnectionDataBuffer[idx].preRcVertexHitInfo.z).xy;

    // pixelColor += metallicRoughness.y;
  }
  pixelColor /= rtxState.maxSamples;

  // Debug - Heatmap
  if(rtxState.debugging_mode == eHeatmap)
  {
    uint64_t end  = clockRealtimeEXT();
    float    low  = rtxState.minHeatmap;
    float    high = rtxState.maxHeatmap;
    float    val  = clamp((float(end - start) - low) / (high - low), 0.0, 1.0);
    pixelColor    = temperature(val);

    // Wrap & SM visualization
    // pixelColor = temperature(float(gl_SMIDNV) / float(gl_SMCountNV - 1)) * float(gl_WarpIDNV) / float(gl_WarpsPerSMNV - 1);
  }

  // uvec4 gInfo = imageLoad(lastGbuffer, imageCoords);
  // vec3 normal = decompress_unit_vec(gInfo.y);
  // vec3 albedo = unpackUnorm4x8(gInfo.w).xyz;

  // Saving pixel color
  if(rtxState.frame > 0)
  {
    // Do accumulation over time
    vec3 old_color  = imageLoad(resultImage, imageCoords).xyz;
    vec3 new_result = mix(old_color, pixelColor, 1.0f / float(rtxState.frame + 1));
    //imageStore(resultImage, imageCoords, vec4(new_result, 1.f));
  }
  else
  {
    // First frame, replace the value in the buffer
    // imageStore(resultImage, imageCoords, vec4(pixelColor, 1.f));
  }

  // A flag shows if the pixel first hit the environment
  bool firstHitEnv = (uintBitsToFloat(imageLoad(thisGbuffer, imageCoords).x) == INFINITY);

  if(firstHitEnv)
  {
      imageStore(resultImage, imageCoords, vec4(pixelColor, 1.f));
  }
  // imageStore(resultImage, imageCoords, vec4(pixelColor, 1.f));
  // Debug
  // imageStore(debugImage, imageCoords, vec4(pixelColor, 1.f));
  // if(idx == 0)
  // {
  //   vec4 res = unpackSnorm4x8(uint(14055679));
  //   imageStore(resultImage, imageCoords, res);
  // }
}
