#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "host_device.h"

layout(push_constant) uniform _RtxState {
  RtxState rtxState;
};

#include "globals.glsl"

PtPayload prd;
ShadowHitPayload shadow_payload;
ivec2 imageCoords;

#include "layouts.glsl"
#include "random.glsl"
#include "common.glsl"
#include "traceray_rq.glsl"

#include "pathtrace_initial.glsl"

#define FIREFLIES 1

layout(local_size_x = RayTraceBlockSizeX, local_size_y = RayTraceBlockSizeY) in;

// Find the Temporal reuse sample
bool findTemporalNeighbor(
    vec3 norm, float depth, float reprojDepth, uint matId, ivec2 prevCoord, out DirectReservoir resv)
{
    vec3 pnorm; 
    float pdepth; 
    uint matHash;

    // Check if the previous coordinate is in bound
    if (!inBound(prevCoord, rtxState.size)) {
        return false;
    }

    // Load the previous geometry info
    loadLastGeometryInfo(prevCoord, pnorm, pdepth, matHash);

    if (hash8bit(matId) == matHash)
    {
        // Check if the sample has similar geom properties
        if (dot(norm, pnorm) > 0.9 && reprojDepth < pdepth * 1.05) 
        {
            resv = prevDirectResv[prevCoord.y * rtxState.size.x + prevCoord.x];
            return true;
        }
    }

    return false;
}

void saveNewReservoir(DirectReservoir resv) {
    currentDirectResv[imageCoords.y * rtxState.size.x + imageCoords.x] = resv;
}

vec2 createMotionVector(vec3 wpos) {
    vec4 proj = sceneCamera.lastProjView * vec4(wpos, 1.0);
    vec3 ndc = proj.xyz / proj.w;
    return ndc.xy * 0.5 + 0.5;
}

ivec2 createMotionIndex(vec3 wpos) {
    return ivec2(createMotionVector(wpos) * vec2(rtxState.size));
}

// The target function
vec3 PHatDirect(DirectReservoir resv, State state, vec3 wo) 
{
    return resv.lightSample.Li * Eval(state, wo, state.ffnormal, resv.lightSample.wi, dummyPdf) *
        absDot(state.ffnormal, resv.lightSample.wi);
}

// W = (1/p_hat) * (total_weight / M)
float WDirect(DirectReservoir resv, State state, vec3 wo)
{
    return resv.weight / (Luminance(PHatDirect(resv, state, wo)) *  float(resv.M));
}

vec3 RayTraceRestirDI(Ray r)
{
	// Compute 1D index
    int idx = imageCoords.y * rtxState.size.x + imageCoords.x;

    // Get Intersection
    ClosestHit(r);

    // Hit env
    if(prd.hitT >= INFINITY)
    {
        imageStore(thisGbuffer, imageCoords, uvec4(floatBitsToUint(INFINITY), 0, 0, InvalidMatId));
    }


    vec3 res;
    return res;
}

void main()
{
    ivec2 imageRes = rtxState.size;
    imageCoords = ivec2(gl_GlobalInvocationID.xy);
    if (imageCoords.x >= imageRes.x || imageCoords.y >= imageRes.y) 
    {
        return;
    }
    
    imageStore(resultImage, imageCoords, vec4(0.0f, 1.0f, 0.0f, 1.f));
}